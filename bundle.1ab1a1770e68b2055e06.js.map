{"version":3,"file":"bundle.1ab1a1770e68b2055e06.js","mappings":";;AAQA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAGA;ACjBA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AAGA;AAEA;;;;;ACTA;AACA;;AAGA;AACA;AACA;AACA;AAEA;;;;AAKA;;;AAGA;;;;;;;;;AAUA;;;;AAKA;ACrCA;AACA;AAEA;;ACYA;AACA;AAaA;;;;ACkFA;AA6CA;;AAEA;AAEA","sources":["webpack://@digicatapult/veritable-portal/./node_modules/@digicatapult/ui-component-library/lib/Heading/index.js","webpack://@digicatapult/veritable-portal/./node_modules/@digicatapult/ui-component-library/lib/Section/index.js","webpack://@digicatapult/veritable-portal/./node_modules/@digicatapult/ui-component-library/lib/Dropdown/index.js","webpack://@digicatapult/veritable-portal/./node_modules/@digicatapult/ui-component-library/lib/Grid/GridPanel.js","webpack://@digicatapult/veritable-portal/./node_modules/@digicatapult/ui-component-library/lib/Grid/index.js","webpack://@digicatapult/veritable-portal/./node_modules/@digicatapult/ui-component-library/lib/QRReader/index.js"],"sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport styled from 'styled-components';\nconst headingProps = `\n  font-size: 1em;\n  padding: 0;\n  margin: 0;\n`;\nexport const H1 = styled.h1 `\n  ${headingProps}\n`;\nexport const H2 = styled.h2 `\n  ${headingProps}\n`;\nexport const H3 = styled.h3 `\n  ${headingProps}\n`;\nexport const H4 = styled.h4 `\n  ${headingProps}\n`;\nexport const H5 = styled.h5 `\n  ${headingProps}\n`;\nexport const H6 = styled.h6 `\n  ${headingProps}\n`;\nconst Headings = [H1, H2, H3, H4, H5, H6];\nexport const HX = ({ children, headingLevel, ...props }) => {\n    const Heading = Headings[headingLevel - 1];\n    return _jsx(Heading, { ...props, children: children });\n};\n","import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { useId } from 'react-id-generator';\nimport styled from 'styled-components';\nimport { HX } from '../Heading/index.js';\nconst Section = ({ title, children, headingLevel, headingGap = '0.5em', headingSize = '1.2em', background = '#f0f0f0', padding = '1em', margin = '0', width = 'auto', height = 'auto', }) => {\n    const [labelId] = useId();\n    return (_jsxs(Wrapper, { \"aria-labelledby\": labelId, background: background, padding: padding, margin: margin, width: width, height: height, children: [_jsx(Heading, { headingLevel: headingLevel, size: headingSize, gap: headingGap, children: title }), children] }));\n};\nconst Wrapper = styled.section `\n  background: ${({ background }) => background};\n  padding: ${({ padding }) => padding};\n  width: ${({ width }) => width};\n  height: ${({ height }) => height};\n  margin: ${({ margin }) => margin};\n`;\nconst Heading = styled(HX) `\n  font-size: ${({ size }) => size};\n  margin: 0;\n  padding: 0;\n  margin-bottom: ${({ gap }) => gap};\n`;\nexport default Section;\n","import { createElement as _createElement } from \"react\";\nimport { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport React from 'react';\nimport Select, { components } from 'react-select';\nimport styled from 'styled-components';\nimport { HX } from '../Heading/index.js';\nconst { Placeholder } = components;\nconst Value = styled('div') `\n  padding: 4px;\n  margin: 4px;\n  margin-left: 0;\n  font-size: 1rem;\n  color: ${(props) => props.textColor || '#FFFFFF'};\n  background-color: ${(props) => props.color || '#99A0A3'};\n  user-select: none;\n`;\nconst Wrapper = styled.div `\n  min-height: ${({ minHeight }) => minHeight || ''};\n  min-width: ${({ minWidth }) => minWidth || ''};\n  width: ${({ width }) => width || '100%'};\n`;\nconst ValuesContainer = styled('div') `\n  display: flex;\n  flex-wrap: wrap;\n  align-items: flex-start;\n`;\nconst Close = styled('button') `\n  all: unset;\n  margin-left: 20px;\n  color: ${({ color }) => color || '#FFFFFF'};\n  transition: fill 0.5s ease-in-out;\n  cursor: pointer;\n  &:hover {\n    color: #bb392d;\n  }\n  &:focus {\n    color: #c82f21;\n  }\n`;\nconst Title = styled(HX) `\n  margin: 0;\n  padding: 0;\n  margin-bottom: 5px;\n`;\nconst HiiMultiSelect = ({ onChange, value = [], ...props }) => {\n    const HiiLabel = (labelProps) => {\n        return (_jsxs(_Fragment, { children: [_jsx(Placeholder, { ...labelProps, isFocused: labelProps.isFocused, children: labelProps.selectProps.placeholder }), React.Children.map(labelProps.children, (child) => child && child.type !== Placeholder ? child : null)] }));\n    };\n    const styles = {\n        multiValue: (provided) => ({\n            ...provided,\n            display: 'none',\n        }),\n        option: (provided) => ({\n            ...provided,\n            ':hover': {\n                ...provided[':hover'],\n                backgroundColor: '#B6EFA0',\n                color: '#27847A',\n            },\n        }),\n        placeholder: (provided) => ({\n            ...provided,\n            position: 'absolute',\n            padding: '8px 4px',\n        }),\n        menuList: (provided) => ({\n            ...provided,\n            zIndex: 999,\n            color: '#fff',\n            backgroundColor: '#27847A',\n        }),\n    };\n    const handleRemoveValue = (e) => {\n        if (!onChange)\n            return null;\n        const { name } = e.currentTarget;\n        const removedValue = value.find((val) => val.value === name);\n        if (!removedValue)\n            return null;\n        onChange(value.filter((val) => val.value !== name));\n    };\n    return (_jsxs(_Fragment, { children: [_jsx(Select, { styles: styles, theme: (provided) => ({\n                    ...provided,\n                    borderRadius: 0,\n                }), components: {\n                    ValueContainer: HiiLabel,\n                }, ...props, value: value, closeMenuOnSelect: true, controlShouldRenderValue: true, onChange: onChange, isSearchable: false }), _jsx(ValuesContainer, { children: value.map((val) => (_createElement(Value, { ...val, key: val.value },\n                    _jsx(\"span\", { children: val.label }),\n                    _jsx(Close, { color: val.textColor, name: val.value, onClick: handleRemoveValue, children: \"x\" })))) })] }));\n};\nconst Dropdown = ({ variant = null, options, isMulti = false, ...props }) => {\n    const [value, setValue] = React.useState(props.selected);\n    const update = (val) => props.update(val);\n    const onChange = (val) => {\n        update(val);\n        setValue(val);\n    };\n    return (_jsxs(Wrapper, { minHeight: props.minHeight, minWidth: props.minWidth, children: [props.label && _jsx(Title, { headingLevel: 4, children: props.label }), variant === 'hii' ? (_jsx(HiiMultiSelect, { isMulti: true, options: options, variant: 'hii', value: value, onChange: onChange, ...props })) : (_jsx(Select, { value: value, options: options, isMulti: isMulti, onChange: onChange, closeMenuOnSelect: true, ...props }))] }));\n};\nexport default Dropdown;\n","import { jsx as _jsx } from \"react/jsx-runtime\";\nimport styled from 'styled-components';\n// TODO remove this, just to prove that ts extension works.\nconst Panel = ({ children, ...props }) => {\n    return _jsx(Wrapper, { ...props, children: children });\n};\nconst Wrapper = styled('div') `\n  grid-area: ${({ area }) => area};\n  ${({ justifySelf }) => (justifySelf ? `justify-self: ${justifySelf}` : '')};\n`;\nexport default Panel;\n","import { jsx as _jsx } from \"react/jsx-runtime\";\nimport styled from 'styled-components';\nimport Panel from './GridPanel.js';\nconst Grid = Object.assign((propsWithC) => {\n    const { children, ...props } = propsWithC;\n    return _jsx(Wrapper, { ...props, children: children });\n}, {\n    Panel,\n});\nGrid.Panel = Panel;\nconst interpolateLayout = ({ areas, rows, columns, gap, alignItems, }) => {\n    return `\n    grid-template-areas: ${areas.map((row) => `\"${row.join(' ')}\"`).join('\\n')};\n    grid-template-rows: ${rows.join(' ')};\n    grid-template-columns: ${columns.join(' ')};\n    gap: ${gap || '0px'};\n    ${alignItems ? `align-items: ${alignItems};` : ''}\n\n  `;\n};\nconst Wrapper = styled('div') `\n  display: grid;\n  ${interpolateLayout}\n  ${({ byWidth }) => {\n    const entries = byWidth\n        ? byWidth.map(({ minWidth, ...props }) => {\n            return `\n        @media (min-width: ${minWidth}px) {\n          ${interpolateLayout(props)}\n        }\n      `;\n        })\n        : [];\n    return entries.join('\\n');\n}}\n`;\nexport default Grid;\n","import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { styled } from 'styled-components';\nimport { useState, useEffect, useRef, useCallback } from 'react';\nimport { createWorker } from './worker.util.js';\nimport { getUserMedia } from './userMedia.util.js';\nconst delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nconst QRReader = ({ onResult, scanDelay = 500, viewFinderColor = '#55555580', viewFinderVariant = 'viewfinder-cross-med', className, mirror = false, }) => {\n    const [result, setResult] = useState(null);\n    const [error, setError] = useState(null);\n    const videoRef = useRef(null);\n    const canvasRef = useRef(null);\n    const workerRef = useRef(null);\n    // kick off the webworker that will process qr decode requests\n    useEffect(() => {\n        const worker = createWorker();\n        workerRef.current = worker;\n        return () => {\n            worker.terminate();\n        };\n    }, []);\n    // hook to initialise the media loop\n    useEffect(() => {\n        const constraints = { video: { facingMode: 'environment' } };\n        let stream = null;\n        getUserMedia(constraints)\n            .then((mediaStream) => {\n            const video = videoRef.current;\n            if (!video) {\n                // this should never happen\n                throw new Error('Video was not initialised as expected');\n            }\n            video.srcObject = mediaStream;\n            video.play();\n            stream = mediaStream;\n        })\n            .catch((err) => {\n            // TODO: trigger an error state and render a fallback\n            console.error('Error accessing webcam:', err);\n            setError('Error accessing webcam');\n        });\n        return () => {\n            if (!stream) {\n                return;\n            }\n            const tracks = stream.getTracks();\n            tracks.forEach((track) => {\n                track.stop();\n            });\n        };\n    }, [setError]);\n    const parseCurrentFrame = useCallback(async () => {\n        const canvas = canvasRef.current;\n        const video = videoRef.current;\n        const worker = workerRef.current;\n        if (!canvas ||\n            !video ||\n            !worker ||\n            video.readyState !== video.HAVE_ENOUGH_DATA) {\n            return null;\n        }\n        const ctx = canvas.getContext('2d');\n        if (!ctx) {\n            return null;\n        }\n        canvas.height = video.videoHeight * 0.8;\n        canvas.width = video.videoWidth * 0.8;\n        ctx.drawImage(video, 0.1 * video.videoWidth, 0.1 * video.videoHeight, video.videoWidth * 0.8, video.videoHeight * 0.8, 0, 0, canvas.width, canvas.height);\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        const message = {\n            data: imageData.data,\n            width: imageData.width,\n            height: imageData.height,\n        };\n        const result = await new Promise((resolve) => {\n            worker.onmessage = ({ data }) => {\n                if (data.type === 'success') {\n                    const code = data.code;\n                    resolve(code.data);\n                }\n                resolve(null);\n            };\n            worker.postMessage(message);\n        });\n        return result;\n    }, []);\n    // start the decoding loop. Note we store the result in local state so that we don't need to restart the loop just because the onResult handler changes\n    useEffect(() => {\n        let stop = false;\n        const loop = async () => {\n            while (true) {\n                if (stop) {\n                    return;\n                }\n                const result = await parseCurrentFrame();\n                if (stop) {\n                    return;\n                }\n                setResult(result);\n                await delay(scanDelay);\n            }\n        };\n        loop();\n        return () => {\n            stop = true;\n        };\n    }, [setResult, scanDelay, parseCurrentFrame]);\n    // Update the parent on result changes whenever they happen\n    useEffect(() => {\n        if (result) {\n            onResult(result);\n        }\n    }, [result, onResult]);\n    return error ? (_jsx(\"div\", { className: className, children: error })) : (_jsxs(Wrapper, { className: className, \"$showViewfinder\": viewFinderVariant === 'viewfinder-cross-med', \"$viewFinderColor\": viewFinderColor, children: [_jsx(Video, { ref: videoRef, muted: true, \"$mirror\": mirror }), _jsx(\"canvas\", { ref: canvasRef, hidden: true })] }));\n};\nconst Wrapper = styled.div `\n  width: 100%;\n  position: relative;\n\n  ${({ $showViewfinder, $viewFinderColor }) => $showViewfinder\n    ? `\n  &:before {\n    content: '';\n    position: absolute;\n    display: inline-block;\n    top: 10%;\n    left: 10%;\n    right: 10%;\n    bottom: 10%;\n    opacity: 0.2;\n    background:\n      linear-gradient(to right, ${$viewFinderColor} 4px, transparent 4px) 0 0,\n      linear-gradient(to right, ${$viewFinderColor} 4px, transparent 4px) 0 100%,\n      linear-gradient(to left, ${$viewFinderColor} 4px, transparent 4px) 100% 0,\n      linear-gradient(to left, ${$viewFinderColor} 4px, transparent 4px) 100% 100%,\n      linear-gradient(to bottom, ${$viewFinderColor} 4px, transparent 4px) 0 0,\n      linear-gradient(to bottom, ${$viewFinderColor} 4px, transparent 4px) 100% 0,\n      linear-gradient(to top, ${$viewFinderColor} 4px, transparent 4px) 0 100%,\n      linear-gradient(to top, ${$viewFinderColor} 4px, transparent 4px) 100% 100%;\n\n    background-repeat: no-repeat;\n    background-size: 20px 20px;\n  }\n\n  &:after {\n    content: '';\n    position: absolute;\n    display: inline-block;\n    top: 10%;\n    left: 10%;\n    right: 10%;\n    bottom: 10%;\n    opacity: 0.2;\n    background:\n      linear-gradient(to right, ${$viewFinderColor} 4px, transparent 4px)\n        calc(50% + 30px - 2px) 50%,\n      linear-gradient(to bottom, ${$viewFinderColor} 4px, transparent 4px) 50%\n        calc(50% + 30px - 2px);\n\n    background-repeat: no-repeat;\n    background-size: 60px 60px;\n  }`\n    : ''}\n`;\nconst Video = styled.video `\n  width: 100%;\n  ${({ $mirror }) => ($mirror ? 'transform:  scaleX(-1);' : '')}\n`;\nexport default QRReader;\n"],"names":[],"sourceRoot":""}